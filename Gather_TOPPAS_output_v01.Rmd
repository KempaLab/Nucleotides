---
title: "Gather TOPPAS output"
subtitle: "PROJECTNAME, data stiched with Version 1"
author: "Tobias Opialla"
date: "July 17, 2019"
output: 
  html_document:
    toc: TRUE
  word_document:
    toc: TRUE
abstract: "Script to make dataframe from a list of TOPPAS output files. An inputfile with the nucleotide names is needed, a certain file name structure (see below) and it has to be checked if absolute quantification information is included in the dataset. If the script throws errors about missing packages, please install them through the 'Packages'-tab in RStudio. \n All output files will be named by the time they were generated at to avoid file overwriting." 

params:
  directory_path_TOPPAS_output: "./input_files"
  nucleotide_name_map_file_path: "./nucleotide_names_mapping.csv" #could be integrated into TOPPAS
  use_quant_at_all: TRUE # TRUE #set to false if absolute quantification should be ignored
  use_quant_filter_list: FALSE #if in a second (or later) round certain entries from quant should be removed, modify the filterlist generated by this script, and put the appropriate file path here, e.g. "Calibration_points_YYYYMMdd_HH-mm-ss.tsv"
 
---


# Add information about performed experiment

All raw data were processed with TOPPAS PIPELINE CB designed (generating the median of at least 20 scans per file for both transitions of each nucleotide (named 1 and 2 in file)). Both transitions were summarised and named as 12. Pipeline export was processed using the script sample_processing getting the output file "sample_data" and "Nucleotides_summarised_01-18". First named file is used in this script to determine the absolute concentrations using the Calibration curve. The calibration curve consits of 9 data points - ranging from 0.02 µmol/L to 10 µmol/L.

CALIBRATION curve was measured in triplicate.


# Expected file naming, input files

## set input file path

All files from TOPPAS to be included in this analysis should be included in the directory specified on top of this script under `directory_path_TOPPAS_output:`

Preferably use a relative path to this script.


***below here normally nothing has to be changed***

## File naming

For samples the script expects `sample`, for quants `NucleoMix` and for blanks `blank` in the filename.

If you do not keep to the denoted file naming, the regular expressions or other places in the code have to be changed. The file names will be split at the `_` characters, so do not introduce additional `_` characters.  
The additional `_` for `NucleoMix_X` will be handled by the script, it can also be left out.


Columns regarding file names will be named as follows:

`date`, `Operator`, `Sample`, `replicate`

Input file names will be identified by the `.unknown` ending of the file name.



### Samples

For the file naming to work the structure should be as follows:
`20190521_XX_sample3_02.unknown` so

* Date in `YYYYMMdd`
* Operator initials `XX`
* `sample` followed directly by number to identify it as sample, and to identify the sample
* replicate number

The script looks for the string `sample` to discern samples (from calibration curve samples etc).

### Quants

For the file naming to work the structure should be as follows:
`20190521_XX_NucleoMix_A_01.unknown` so 

* Date in `YYYYMMdd`
* Operator initials `XX`
* `NucleoMix` to identify the file as calibration measurement
* UPPERCASE letter to denote the calibration solution
* replicate number

The script looks for the string `NucleoMix` to discern calibration curve samples.

### Blanks
For the file naming to work the structure should be as follows:
`20190521_XX_TrueBlank_01.unknown`

* Date in `YYYYMMdd`
* Operator initials `XX`
* `TrueBlank` followed directly by number to identify it as blank, and to identify the sample
* replicate number

The script looks for the string `TrueBlank` to discern calibration curve samples.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message=FALSE,             # Show Messages
                      error=TRUE,                # Show Errors
                      warning=FALSE,              # Show warnings
                      cache=FALSE,
                      #results='markup',          # Forwarding output to standard hook (output)
                      out.width='\\linewidth',
                      fig.align='center',
                      fig.show='asis',
                      fig.pos='H',
                      fig.width=8)

library(tidyverse)
library(ggplot2)
library(ggpmisc)
library(purrr)
library(broom)
library(openxlsx)
```

# Calibration curve concentrations

Change entries here, if you'd like to use different calibration curve solution concentrations. All values are given in µmol/L concentrations.

```{r calibration curve concentration levels, echo=T}
concentration_Levels= #all given in µmol/L
  c("A" =	10,
    "B" =	5,
    "C" =	2,
    "D" =	1,
    "E" =	0.5,
    "F" =	0.2,
    "G" =	0.1,
    "H" =	0.05,
    "I" =	0.02)

#all given in µmol/L

```


***after here only change things, when you know, what you're doing :-)***

# Generate time stamp

```{r make time stamp}
#generate time stamp for all files created by this instance of script running. 
#(un)comment appropriately if you want to get rid of that
mytimestamp=paste0("_",format(Sys.time(),"%Y%m%d_%H-%M-%S")) #format a string giving YearMonthDay_hour-minute-second

#  mytimestamp=NULL

```

The timestamp used for output from this script is ` `r mytimestamp` `.

# Read in dataframes from TOPPAS output and add information about nucleotides

```{r read in TOPPAS output}

# get all files that end in ".unknown" in the directory specified above
file.list <- list.files(path = params$directory_path_TOPPAS_output,pattern='*.unknown',full.names = T,recursive = F)
file.list <- setNames(file.list, basename(file.list)) #add bare file names as names for input file list

df <- map_df(file.list, read.delim, .id = "file") 

cat(paste("read",length(file.list),"file(s) from path",
          paste0("'",params$directory_path_TOPPAS_output,"'")))
```

```{r structure dataframe}

#split meta info from file names into columns 

df = df %>% mutate (
  file_name_reformatted=
    str_replace_all(file,"NucleoMix_","NucleoMix") %>% 
    str_remove_all(".unknown")) %>% 
  separate(file_name_reformatted,into=c('date', 'Operator', 'sample', 'replicate'),sep="_")

# according to TOPPAS, output is the mean and not the median of both transitions
df=df %>% rename(sum_intensity=median,
                 transition_no=transition,
                 nucleotide_no=nuc) %>%
  filter(transition_no==12) #we keep only the means of both transitions
```

```{r add nucleotide names}

#read nucleotide names, rename columns
df_nucleotide_names=read.csv(params$nucleotide_name_map_file_path,stringsAsFactors = F)

#if it's an old file, rename columns
if("nuc_nb"%in%names(df_nucleotide_names)){ 
  df_nucleotide_names=rename(df_nucleotide_names,nucleotide_no=nuc_nb)
}
if("nuc"%in%names(df_nucleotide_names)){
  df_nucleotide_names=rename(df_nucleotide_names,nucleotide_name=nuc)
}

#add nucleotide names and meta info to dataframe
df=left_join(df, df_nucleotide_names)

df=df %>% select(file, date, Operator, sample, replicate,
                 nucleotide_no, nucleotide_name,base,sugar,phosphorylation,transition_no, sum_intensity, cv)

```

# separate blanks out

```{r separate blanks}

df_blanks=df %>% filter(grepl("TrueBlank",sample,ignore.case = T))

```



# Calibration curve calculations

```{r create dataframe to redact samples}

if(params$use_quant_at_all){ #only run, if quant information should be used at all, has to be present
  
  
  df_quant=df %>% filter(grepl("NucleoMix",sample,ignore.case = T))
  df_quant$use_for_analysis_linear=TRUE
  df_quant$use_for_analysis_square=TRUE
  df_quant=df_quant %>% 
    mutate(concentration_micmol_L=
             concentration_Levels[match(
               gsub("NucleoMix","",sample,ignore.case = T),names(concentration_Levels))]) %>% 
    arrange(nucleotide_name,sample,replicate) %>% #sort rows for nicer output
    select(nucleotide_name, sample, concentration_micmol_L,replicate, sum_intensity, #reorder columns
           use_for_analysis_linear,use_for_analysis_square, 
           file,nucleotide_no, date, Operator, transition_no, cv)
  
  write.table(df_quant,
              paste0("Calibration_points",mytimestamp,".tsv"),
              row.names = F,col.names = T,quote=F,sep="\t")
  
}
```

## linear fit

```{r generate quant df linear}
if(params$use_quant_at_all){ #only run, if quant information should be used at all, has to be present
  
  # decide if external filter list should be used at all and read in file...
  if(params$use_quant_filter_list!=FALSE){ 
    
    df_quant = read.delim(params$use_quant_filter_list,stringsAsFactors = FALSE)
    
  }
  
  df_quant_linear=df_quant %>% 
    filter(use_for_analysis_linear) #filter which quant values should be used for analysis  
  
  # (re) add concentration information on standard dilutions
  df_quant_linear=df_quant_linear %>%
    mutate(concentration_micmol_L=
             concentration_Levels[match(gsub("NucleoMix","",sample,ignore.case = T),names(concentration_Levels))])
  
  # generate fits and get parameters out, here one could add other separators, e.g.batches
  
  df_fits_res=df_quant_linear %>% ungroup() %>% 
    nest(-nucleotide_name,-nucleotide_no) %>% 
    mutate(fit = map(data, ~ lm(sum_intensity ~ concentration_micmol_L, data = .x)), 
           tidied=map(fit,glance)) %>% 
    unnest(tidied)
  df_fits=df_quant_linear %>% ungroup %>% nest(-nucleotide_name,-nucleotide_no) %>% 
    mutate(fit = map(data, ~ lm(sum_intensity ~ concentration_micmol_L, data = .x)),
           tidied=map(fit,tidy)) %>% unnest(tidied) %>%  
    select(nucleotide_no,nucleotide_name, term, estimate) %>% 
    spread(term, estimate)
  
  # join fit statistics and parameters, rename columns for more convenient processing
  
  df_fit_parameters_linear=inner_join(df_fits,df_fits_res )#%>% select(nucleotide_name,nucleotide_no,r.squared))
  names(df_fit_parameters_linear)[grep("Intercept",names(df_fit_parameters_linear))]="Intercept"
  
  
  # get min and max values to determine range of calibration curve
  df_quant_minmax_linear=df_quant %>% ungroup() %>% group_by(nucleotide_no,nucleotide_name) %>% 
    summarise(concenctration_quant_max_linear=max(concentration_micmol_L,na.rm = T),
              concenctration_quant_min_linear=min(concentration_micmol_L,na.rm = T))
  
  # add range of calibration curve
  df_fit_parameters_linear=left_join(df_fit_parameters_linear,df_quant_minmax_linear)
  
  df_fit_parameters_linear=df_fit_parameters_linear %>% select(
   nucleotide_no, nucleotide_name,Intercept,slope_concentration_micmol_L_fit=concentration_micmol_L,
   data,fit,r.squared,adj.r.squared,p.value,
   concenctration_quant_max_linear,concenctration_quant_min_linear,
   sigma,statistic,df,logLik,AIC,BIC,deviance,df.residual
  )
  # write table of linear fit parameters
  mylinearfilename=paste0("./Calibration_curve_parameters_linear",mytimestamp,".tsv")
  write.table(df_fit_parameters_linear %>% select(-fit,-data),
              mylinearfilename,
              row.names = F,col.names = T,quote=F,sep="\t")
  #cat(paste0('[',mylinearfilename,'](file:///',knitr::opts_knit$get("root.dir"),mylinearfilename,')\n'))
}


```

`r ifelse(params$use_quant_at_all, paste0("Information to exclude certain samples",               ifelse(params$use_quant_filter_list!=FALSE, paste0(" was used from", params$use_quant_filter_list," ."), paste0(" is stored in Quantcurve_values",mytimestamp,".tsv ."))),"")`

If calibration was used, output is in ` `r paste0("./Calibration_curve_parameters_linear",mytimestamp,".tsv")` `.



## squared fit

```{r squared fit}
if(params$use_quant_at_all){#only run, if quant information should be used at all, has to be present
  
  # decide if external filter list should be used at all and read in file...
  if(params$use_quant_filter_list!=FALSE){ 
    
    df_quant = read.delim(params$use_quant_filter_list,stringsAsFactors = FALSE)
    
  }
  
  df_quant_square=df_quant %>%
    filter(use_for_analysis_square) #filter which quant values should be used for analysis  
  
  # add concentration information on standard dilutions
  df_quant_square=df_quant_square %>%
    mutate(concentration_micmol_L=
             concentration_Levels[match(str_remove(sample,"NucleoMix"),names(concentration_Levels))])
  
  
  # generate fits and get parameters out, here one could add other separators, e.g.batches
  
  df_fits_res=df_quant_square %>% ungroup() %>% 
    nest(-nucleotide_name,-nucleotide_no) %>% 
    mutate(fit = map(data, ~ lm(sum_intensity ~ poly(concentration_micmol_L,2,raw=TRUE), data = .x)), 
           tidied=map(fit,glance)) %>% 
    unnest(tidied)
  df_fits=df_quant_square %>% ungroup %>% nest(-nucleotide_name,-nucleotide_no) %>% 
    mutate(fit = map(data, ~ lm(sum_intensity ~ poly(concentration_micmol_L,2,raw=TRUE), data = .x)),
           tidied=map(fit,tidy)) %>%unnest(tidied) %>%  
    select(nucleotide_no,nucleotide_name, term, estimate) %>% 
    spread(term, estimate) %>% 
    setNames(c("nucleotide_no","nucleotide_name","c","b","a"))
  
  
  # join fit statistics and parameters, rename columns for more convenient processing
  df_fit_parameters_square=inner_join(df_fits,df_fits_res)
  #%>%select(nucleotide_name,nucleotide_no,r.squared))
  
  # get min and max values to determine range of calibration curve
  df_quant_minmax_square=df_quant %>% ungroup() %>% group_by(nucleotide_no,nucleotide_name) %>% 
    summarise(concenctration_quant_max_square=max(concentration_micmol_L,na.rm = T),
              concenctration_quant_min_square=min(concentration_micmol_L,na.rm = T))
  
  # add range of calibration curve
  df_fit_parameters_square=left_join(df_fit_parameters_square,df_quant_minmax_square)
  
  df_fit_parameters_square=df_fit_parameters_square %>% select(
    nucleotide_no,nucleotide_name,a,b,c,data,fit,r.squared,adj.r.squared,p.value,
    concenctration_quant_max_square,concenctration_quant_min_square,
    sigma,statistic,df,logLik,AIC,BIC,deviance,df.residual)
  
  # write table of squared fit parameters
  mysquaredfilename= paste0("Calibration_curve_parameters_squared",mytimestamp,".tsv")
  write.table(df_fit_parameters_square %>% select(-fit,-data),
              mysquaredfilename,
              row.names = F,col.names = T,quote=F,sep="\t")
}
```

`r ifelse(params$use_quant_at_all, paste0("Information to exclude certain samples",               ifelse(params$use_quant_filter_list!=FALSE, paste0(" was used from", params$use_quant_filter_list," ."), paste0(" is stored in Quantcurve_values",mytimestamp,".tsv ."))),"")`

If calibration was used, output is in ` `r paste0("./Calibration_curve_parameters_squared",mytimestamp,".tsv")` `.


# Plot calibration curves

```{r define color scale}

df$replicate %>% unique()
mycolorscale=RColorBrewer::brewer.pal(n=length(unique(df$replicate)),name = "Set1")
names(mycolorscale)=unique(df$replicate)

mycolorscale=scale_color_manual(values=c("InRange"="green","OutOfRange"="deeppink2",
                                         mycolorscale)) 
#other colors are Color Brewer colors from 'Set1'

```

```{r plot calibration curves}
if(params$use_quant_at_all){ #only run, if quant information should be used at all, has to be present
  #linear fits 
  my.formula <- y ~ x #define linear formula
  
  p_linear=ggplot(data = df_quant_linear, aes(x = concentration_micmol_L, y = sum_intensity,group=1)) +
    geom_hline(data=df_blanks,aes(yintercept=sum_intensity,linetype=replicate), color="black")+
    geom_smooth(method = "lm", se=FALSE, formula = my.formula,color="black") +
    stat_poly_eq(formula = my.formula, 
                 aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                 parse = TRUE,coef.digits = 5,size=3,color="black") +
    
    geom_point(aes(color=replicate,shape=replicate))+
    mycolorscale+
    labs(linetype="Blank replicate",color="Quant replicate",shape="Quant replicate")+
    
    #scale_color_viridis(discrete = T)+
    facet_wrap(~nucleotide_name,scales = "free")
  
  ggsave(plot=p_linear, paste0("calibration_curves_linear",mytimestamp,".pdf"),
         height = 20*9/16,width=20)
  
  # squared fits 
  my.formula_square= y ~ poly(x,2,raw=TRUE) #define squared formula
  
  p_square=ggplot(data = df_quant_square, aes(x = concentration_micmol_L, y = sum_intensity,group=1)) +
    geom_hline(data=df_blanks,aes(yintercept=sum_intensity,linetype=replicate), color="black")+
    geom_smooth(method = "lm", se=FALSE, formula = my.formula_square,color="red") +
    stat_poly_eq(formula = my.formula_square, 
                 aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                 parse = TRUE,coef.digits = 5,size=3,color="red") +
    
    geom_point(aes(color=replicate,shape=replicate))+
    mycolorscale+
    labs(linetype="Blank replicate",color="Quant replicate",shape="Quant replicate")+
    #scale_color_viridis(discrete = T)+
    facet_wrap(~nucleotide_name,scales = "free")
  
  ggsave(plot=p_square,file=paste0("calibration_curves_square",mytimestamp,".pdf"),
         height = 20*9/16,width=20)
}

```

Now go and check calibration curves, enter `FALSE` in the appropriate entries in the  `Calibration_curve_parameters_XX.tsv` files and rerun this script with appropriate input file adjustments.

Plots are in ` `r paste0("calibration_curves_square",mytimestamp,".pdf")` `.

# Calculate and plot values for linear fit

```{r calculate absolute quantities linear}
if(params$use_quant_at_all){ #only run, if quant information should be used at all, has to be present
  #linear fits 
  
  #add fit parameters to samples-dataframe
  df_samples=left_join(df %>% filter(str_detect(sample,"sample")|str_detect(sample,"TrueBlank")),
                       df_fit_parameters_linear %>% 
                         select(nucleotide_no,nucleotide_name,
                                Intercept,slope_concentration_micmol_L_fit,
                                concenctration_quant_max_linear,concenctration_quant_min_linear))
  
  # calculate concentration according to fitted parameters
  df_samples=mutate(df_samples,concentration_micmol_L_calc_linear=
                      (sum_intensity - Intercept) / slope_concentration_micmol_L_fit
  )
  
  # check if samples are in range of quant
  
  df_samples=df_samples %>% #ungroup %>% group_by(nucleotide_name) %>% 
    mutate(sample_in_range_linear=
             ifelse(concentration_micmol_L_calc_linear < concenctration_quant_min_linear, "below",
                    ifelse(concentration_micmol_L_calc_linear<concenctration_quant_max_linear & 
                             concentration_micmol_L_calc_linear>concenctration_quant_min_linear,
                           "within",
                           ifelse(concentration_micmol_L_calc_linear>concenctration_quant_max_linear,
                                  "above",NA)
                    )
             )
    )
  
  my.formula <- y ~ x #set formula to linear
  
  #plot calibration curves with samples on them
  
  p_linear_samples=ggplot(data = df_quant, aes(x = concentration_micmol_L, y = sum_intensity,group=1)) +
    geom_hline(data=df_blanks,aes(yintercept=sum_intensity,linetype=replicate), color="black")+
    geom_smooth(method = "lm", se=FALSE, formula = my.formula,color="black") +
    stat_poly_eq(formula = my.formula, 
                 aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                 parse = TRUE,coef.digits = 5,size=3) +         
    geom_point(aes(color=replicate,shape=replicate,size=2,alpha=0.5))+
    
    geom_point(data=df_samples %>% filter(sample_in_range_linear=="within"),
               aes(x=concentration_micmol_L_calc_linear,y=sum_intensity,
                   shape=replicate,color="InRange"),size=5,shape=4)+
    geom_point(data=df_samples %>% filter(sample_in_range_linear!="within"),
               aes(x=concentration_micmol_L_calc_linear,y=sum_intensity,
                   shape=replicate,color="OutOfRange"),size=5,shape=4,)+
    mycolorscale+
    labs(linetype="Blank replicate",color="Quant replicate",shape="Quant replicate")+
    #scale_color_viridis(discrete = T)+
    facet_wrap(~nucleotide_name,scales = "free")
  
  ggsave(plot=p_linear_samples,file=
           paste0("calibration_curves_linear_with_samples",mytimestamp,".pdf"),
         height = 20*9/16,width=20)
  
}else{
  df_samples=df %>% filter(str_detect(sample,"sample"))
}

```

Plots are in ` `r paste0("calibration_curves_linear_with_samples",mytimestamp,".pdf")` `.


# Calculate and plot values for squared fit

```{r calculate absolute quantities squared}
if(params$use_quant_at_all){#only run, if quant information should be used at all, has to be present
  #squared fits
  
  #add fit parameters to samples-dataframe
  df_samples_square=left_join(df %>% filter(str_detect(sample,"sample")|str_detect(sample,"TrueBlank")),
                              df_fit_parameters_square %>% 
                                select(nucleotide_no,nucleotide_name,
                                       a,b,c,
                                       concenctration_quant_max_square,concenctration_quant_min_square))
  
  # calculate concentration according to fitted parameters
  df_samples_square=df_samples_square %>% 
    mutate(concentration_micmol_L_calc_square=(b*(-1)+sqrt(b^2 - (4*a*(c-sum_intensity))))/(2*a))
  
  # check if samples are in range of quant
  df_samples_square=df_samples_square %>% #ungroup %>% group_by(nucleotide_name) %>% 
    mutate(sample_in_range_square=
             ifelse(concentration_micmol_L_calc_square < 
                      concenctration_quant_min_square, "below",
                    ifelse(concentration_micmol_L_calc_square<concenctration_quant_max_square & 
                             concentration_micmol_L_calc_square>concenctration_quant_min_square,
                           "within", ifelse(concentration_micmol_L_calc_square >
                                              concenctration_quant_max_square,"above",NA)
                    )
             )
    )
  
  my.formula_square= y ~ poly(x,2,raw=TRUE) #set formula to square
  
  #plot calibration curves with samples on them
  
  p_square_samples=ggplot(data = df_quant_square, aes(x = concentration_micmol_L, y = sum_intensity,group=1)) +
    geom_hline(data=df_blanks,aes(yintercept=sum_intensity,linetype=replicate), color="black")+
    geom_smooth(method = "lm", se=FALSE, formula = my.formula_square,color="red") +
    stat_poly_eq(formula = my.formula_square, 
                 aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
                 parse = TRUE,coef.digits = 5,size=3) +         
    geom_point(aes(color=replicate,shape=replicate,size=2,alpha=0.5))+
    
    geom_point(data=df_samples_square %>% filter(sample_in_range_square=="within"),
               aes(x=concentration_micmol_L_calc_square,y=sum_intensity,
                   shape=replicate),size=5,shape=4,color="green")+
    geom_point(data=df_samples_square %>% filter(sample_in_range_square!="within"),
               aes(x=concentration_micmol_L_calc_square,y=sum_intensity,
                   shape=replicate),size=5,shape=4,color="deeppink2")+
    mycolorscale+
    labs(linetype="Blank replicate",color="Quant replicate",shape="Quant replicate")+
    #scale_color_viridis(discrete = T)+
    facet_wrap(~nucleotide_name,scales = "free")
  
  ggsave(plot = p_square_samples,file=paste0("calibration_curves_square_with_samples",
                                             mytimestamp,".pdf"),height = 20*9/16,width=20)
  
  
  
}else{
  df_samples_square=df %>% filter(str_detect(sample,"sample"))
}

```

Plots are in ` `r paste0("calibration_curves_square_with_samples",mytimestamp,".pdf")` `.

# Bind dataframes

Dataframe for all samples with according fit-parameters are prepared.

```{r bind dataframes}
if(params$use_quant_at_all){#only run, if quant information should be used at all, has to be present
  
  df_samples_all=left_join(df_samples,df_samples_square) %>% #rearrange columns
    select(file, date, Operator, sample, replicate, nucleotide_no, nucleotide_name, 
           sum_intensity,concentration_micmol_L_calc_linear,concentration_micmol_L_calc_square, 
           sample_in_range_linear, sample_in_range_square,
           concenctration_quant_min_linear,concenctration_quant_max_linear,
           concenctration_quant_min_square,concenctration_quant_max_square,
           base, sugar, phosphorylation, transition_no,
           cv_sum_intensity=cv, Intercept, slope_concentration_micmol_L_fit,  a, b, c)
  
}else{
  df_samples_all=df %>% filter(grepl("sample|Blank",sample,ignore.case = T)) %>% 
    select(file, date, Operator, sample, replicate, nucleotide_no, nucleotide_name, sum_intensity, cv,
           base, sugar, phosphorylation, transition_no )
}

write.table(df_samples_all,
            paste0("sample_data_bound",mytimestamp,".tsv"),
            row.names = F,col.names = T,quote=F,sep="\t")

write.table(df %>% 
              select(file, date, Operator, sample, replicate, nucleotide_no, nucleotide_name,
                     sum_intensity, cv,base, sugar, phosphorylation, transition_no),
            paste0("all_data",mytimestamp,".tsv"),
            row.names = F,col.names = T,quote=F,sep="\t")


myworkbook=createWorkbook()

df$sampletype=ifelse(grepl("sample",df$file,ignore.case = T), # sampletype will not be exported, 
                     # only used for sorting of wide format columns 
                     "sample",
                     ifelse(grepl("Blank",df$sample,ignore.case = T),
                            "blank",
                            ifelse(grepl("NucleoMix",df$file,ignore.case = T),
                                   "Quant",NA)
                     )
)

df=df %>% arrange(sampletype,file)

df_samples_all$sampletype=ifelse(grepl("sample",df_samples_all$file,ignore.case = T),
                                 # sampletype will not be exported, 
                                 # only used for sorting of wide format columns 
                                 "sample",
                                 ifelse(grepl("Blank",df_samples_all$sample,ignore.case = T),
                                        "blank",
                                        ifelse(grepl("NucleoMix",df_samples_all$file,ignore.case = T),
                                               "Quant",NA)
                                 )
)

df_samples_all=df_samples_all %>% arrange(sampletype,file)


df_intensities=pivot_wider(data=df %>% mutate(file=str_replace_all(file,"unknown",""))
                           , id_cols = c(transition_no,nucleotide_name),
                           names_from = file,
                           values_from = sum_intensity)

addWorksheet(myworkbook,sheetName = "sum_intensities")
myncols=ncol(df_intensities)

writeData(myworkbook,sheet = "sum_intensities",x=df_intensities,
          colNames=TRUE,rowNames=FALSE)

if(params$use_quant_at_all){
  df_absolute_quant_linear=pivot_wider(data=df_samples_all %>% mutate(file=str_replace_all(file,"unknown",""))
                                       , id_cols = c(transition_no,nucleotide_name),
                                       names_from = file,
                                       values_from = concentration_micmol_L_calc_linear)
  
  addWorksheet(myworkbook,sheetName = "absolute_quant_micmol_L_linear")
  myncols=c(myncols,ncol(df_absolute_quant_linear))
  writeData(myworkbook,sheet = "absolute_quant_micmol_L_linear",x=df_absolute_quant_linear,
            colNames=TRUE,rowNames=FALSE)
  
  df_absolute_quant_square=pivot_wider(data=df_samples_all %>% mutate(file=str_replace_all(file,"unknown",""))
                                       , id_cols = c(transition_no,nucleotide_name),
                                       names_from = file,
                                       values_from = concentration_micmol_L_calc_square)
  
  addWorksheet(myworkbook,sheetName = "absolute_quant_micmol_L_square")
  myncols=c(myncols,ncol(df_absolute_quant_square))
  writeData(myworkbook,sheet = "absolute_quant_micmol_L_square",x=df_absolute_quant_square,
            colNames=TRUE,rowNames=FALSE)
}

for(cs in 1:length(myworkbook$sheet_names)){
  addStyle(wb=myworkbook, sheet = myworkbook$sheet_names[cs], 
           style = createStyle(wrapText = TRUE,halign = "left",valign = "top",textDecoration = "bold"),
           rows = 1,cols = 1:myncols[cs])
  freezePane(myworkbook,cs,firstActiveRow=2,firstActiveCol=3)
}

saveWorkbook(myworkbook,file=paste0("all_data_wide_format", mytimestamp,".xlsx"),overwrite = F)


```

Outputs are in ` `r paste0("sample_data_bound",mytimestamp,".tsv")` ` and/or ` `r paste0("all_data",mytimestamp,".tsv")` `.  
Wide format dataframes are in ` `r paste0("all_data_wide_format", mytimestamp,".xlsx")` `. 

```{r generate nucleotide naming csv, eval=FALSE, include=FALSE}

#If needed, run this code to generate the nucleotide name mapping input file.
df_nucleotide_names=
  structure(list(nucleotide_no = 1:36,
                 nucleotide_name = c("dCMP", "dUMP", "dTMP", "CMP", "UMP", "cAMP", "dAMP", "AMP", "dGMP", 
                                     "IMP", "GMP", "dCDP", "dUDP", "dTDP", "CDP", "UDP", "dADP", "ADP", 
                                     "dGDP", "GDP", "dCTP", "dTTP", "CTP", "UTP", "dATP", "ATP", "dGTP", 
                                     "GTP", "UDP-Glc", "GDP-Man", "UDP-GNAc", "NAD+", "NADH", "NADP+", 
                                     "NADPH", "AcCoA"), 
                 
                 base = c("C", "U", "T", "C", "U", "A", "A", "A", "G", "I", "G", "C", "U", "T", "C",
                          "U", "A", "A", "G", "G", "C", "T", "C", "U", "A", "A", "G", "G", "U", "G", 
                          "U", "NAD","NAD", "NAD", "NAD", "AcCoA"),
                 
                 sugar = c("deoxyribose", "deoxyribose", 
                           "deoxyribose", "ribose", "ribose", "ribose", "deoxyribose", "ribose", 
                           "deoxyribose", "ribose", "ribose", "deoxyribose", "deoxyribose", 
                           "deoxyribose", "ribose", "ribose", "deoxyribose", "ribose", "deoxyribose", 
                           "ribose", "deoxyribose", "deoxyribose", "ribose", "ribose", "deoxyribose", 
                           "ribose", "deoxyribose", "ribose", "ribose", "ribose", "ribose", 
                           "ribose", "ribose", "ribose", "ribose", "ribose"), 
                 
                 phosphorylation = c("mono", "mono", "mono", "mono", "mono", "mono", "mono", "mono", 
                                     "mono", "mono", "mono", "di", "di", "di", "di", "di", "di", "di",
                                     "di", "di", "tri", "tri", "tri", "tri", "tri", "tri", "tri", "tri", 
                                     "di", "di", "di", "di", "di", "mono", "mono", "AcCoA")),
            class = "data.frame", row.names = c(NA, -36L))
write.csv(df_nucleotide_names,file="./nucleotide_names_mapping.csv",quote = F,row.names = F,col.names = T)
```

```{r clear output from current directory, eval=FALSE, include=FALSE}
### WARNING!!!! THIS WILL DELETE ALL OUTPUT FILES GENERATED FROM THE SCRIPT WITHOUT UNDO. 
### MORE FOR DEVELOPMENT PURPOSES.

filestodelete=c('Calibration_points','Calibration_curve_parameters_linear','Calibration_curve_parameters_squared',
                'calibration_curves_linear','calibration_curves_square',
                'calibration_curves_linear_with_samples','calibration_curves_square_with_samples',
                'sample_data_bound','all_data','all_data_wide_format','Quantcurve_values')

Tergeo=function(filestodelete="wingardiumleviosaaah"){
  cat("files about to be deleted: \n")
  for(cf in filestodelete){
    t=list.files(pattern=cf)
    if(length(t)>0){
      print(t)
    }
  }  
  x=readline(prompt = "The files above are about to be deleted. are you sure? y/n: ")
  if(x=="y"){
    for(cf in filestodelete){
      file.remove(list.files(pattern=cf))
    }
  }
}

Tergeo(filestodelete=filestodelete)  
rm(filestodelete)
```